"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/config/amplify.ts":
/*!*******************************!*\
  !*** ./src/config/amplify.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var aws_amplify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aws-amplify */ \"./node_modules/aws-amplify/dist/esm/index.mjs\");\n\n// Ensure environment variables are available\nconst requiredEnvVars = {\n    authEndpoint: \"http://localhost:4510/api/auth\",\n    userPoolId: \"eu-central-1_e74eb093dcf54a4893034fe033148536\",\n    userPoolClientId: \"kneag7wvdx7v5eama4fjt1urm1\",\n    region: \"eu-central-1\"\n};\n// Validate environment variables\nObject.entries(requiredEnvVars).forEach((param)=>{\n    let [key, value] = param;\n    if (!value) {\n        throw new Error(\"Missing required environment variable: NEXT_PUBLIC_\".concat(key.toUpperCase()));\n    }\n});\n// Configure Amplify\naws_amplify__WEBPACK_IMPORTED_MODULE_0__.Amplify.configure({\n    Auth: {\n        Cognito: {\n            userPoolEndpoint: requiredEnvVars.authEndpoint,\n            userPoolId: requiredEnvVars.userPoolId,\n            userPoolClientId: requiredEnvVars.userPoolClientId,\n            signUpVerificationMethod: 'code',\n            loginWith: {\n                email: true\n            }\n        }\n    }\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29uZmlnL2FtcGxpZnkudHMiLCJtYXBwaW5ncyI6Ijs7QUFBc0M7QUFFdEMsNkNBQTZDO0FBQzdDLE1BQU1DLGtCQUFrQjtJQUN0QkMsY0FBY0MsZ0NBQXFDO0lBQ25ERyxZQUFZSCwrQ0FBb0M7SUFDaERLLGtCQUFrQkwsNEJBQTJDO0lBQzdETyxRQUFRUCxjQUFrQztBQUM1QztBQUVBLGlDQUFpQztBQUNqQ1MsT0FBT0MsT0FBTyxDQUFDWixpQkFBaUJhLE9BQU8sQ0FBQztRQUFDLENBQUNDLEtBQUtDLE1BQU07SUFDbkQsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsTUFBTSxJQUFJQyxNQUFNLHNEQUF3RSxPQUFsQkYsSUFBSUcsV0FBVztJQUN2RjtBQUNGO0FBRUEsb0JBQW9CO0FBQ3BCbEIsZ0RBQU9BLENBQUNtQixTQUFTLENBQUM7SUFDaEJDLE1BQU07UUFDSkMsU0FBUztZQUNQQyxrQkFBa0JyQixnQkFBZ0JDLFlBQVk7WUFDOUNJLFlBQVlMLGdCQUFnQkssVUFBVTtZQUN0Q0Usa0JBQWtCUCxnQkFBZ0JPLGdCQUFnQjtZQUNsRGUsMEJBQTBCO1lBQzFCQyxXQUFXO2dCQUNUQyxPQUFPO1lBQ1Q7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvc3JjL2NvbmZpZy9hbXBsaWZ5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFtcGxpZnkgfSBmcm9tICdhd3MtYW1wbGlmeSc7XG5cbi8vIEVuc3VyZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIGF2YWlsYWJsZVxuY29uc3QgcmVxdWlyZWRFbnZWYXJzID0ge1xuICBhdXRoRW5kcG9pbnQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FVVEhfRU5EUE9JTlQsXG4gIHVzZXJQb29sSWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1VTRVJfUE9PTF9JRCxcbiAgdXNlclBvb2xDbGllbnRJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfVVNFUl9QT09MX0NMSUVOVF9JRCxcbiAgcmVnaW9uOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BV1NfUkVHSU9OLFxufTtcblxuLy8gVmFsaWRhdGUgZW52aXJvbm1lbnQgdmFyaWFibGVzXG5PYmplY3QuZW50cmllcyhyZXF1aXJlZEVudlZhcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIGVudmlyb25tZW50IHZhcmlhYmxlOiBORVhUX1BVQkxJQ18ke2tleS50b1VwcGVyQ2FzZSgpfWApO1xuICB9XG59KTtcblxuLy8gQ29uZmlndXJlIEFtcGxpZnlcbkFtcGxpZnkuY29uZmlndXJlKHtcbiAgQXV0aDoge1xuICAgIENvZ25pdG86IHtcbiAgICAgIHVzZXJQb29sRW5kcG9pbnQ6IHJlcXVpcmVkRW52VmFycy5hdXRoRW5kcG9pbnQgYXMgc3RyaW5nLFxuICAgICAgdXNlclBvb2xJZDogcmVxdWlyZWRFbnZWYXJzLnVzZXJQb29sSWQgYXMgc3RyaW5nLFxuICAgICAgdXNlclBvb2xDbGllbnRJZDogcmVxdWlyZWRFbnZWYXJzLnVzZXJQb29sQ2xpZW50SWQgYXMgc3RyaW5nLFxuICAgICAgc2lnblVwVmVyaWZpY2F0aW9uTWV0aG9kOiAnY29kZScsXG4gICAgICBsb2dpbldpdGg6IHtcbiAgICAgICAgZW1haWw6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pOyAiXSwibmFtZXMiOlsiQW1wbGlmeSIsInJlcXVpcmVkRW52VmFycyIsImF1dGhFbmRwb2ludCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BVVRIX0VORFBPSU5UIiwidXNlclBvb2xJZCIsIk5FWFRfUFVCTElDX1VTRVJfUE9PTF9JRCIsInVzZXJQb29sQ2xpZW50SWQiLCJORVhUX1BVQkxJQ19VU0VSX1BPT0xfQ0xJRU5UX0lEIiwicmVnaW9uIiwiTkVYVF9QVUJMSUNfQVdTX1JFR0lPTiIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJFcnJvciIsInRvVXBwZXJDYXNlIiwiY29uZmlndXJlIiwiQXV0aCIsIkNvZ25pdG8iLCJ1c2VyUG9vbEVuZHBvaW50Iiwic2lnblVwVmVyaWZpY2F0aW9uTWV0aG9kIiwibG9naW5XaXRoIiwiZW1haWwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/config/amplify.ts\n"));

/***/ }),

/***/ "./src/services/httpService.ts":
/*!*************************************!*\
  !*** ./src/services/httpService.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpService: () => (/* binding */ HttpService)\n/* harmony export */ });\n/* harmony import */ var _loadingService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadingService */ \"./src/services/loadingService.ts\");\n/* harmony import */ var _types_httpError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/types/httpError */ \"./src/types/httpError.ts\");\n/* harmony import */ var aws_amplify_auth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aws-amplify/auth */ \"./node_modules/aws-amplify/dist/esm/auth/index.mjs\");\n/* harmony import */ var _services_authService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/services/authService */ \"./src/services/authService.ts\");\n\n\n\n\nconst API_BASE_URL = \"http://localhost:4510/api\";\nclass HttpService {\n    static getInstance(baseUrl) {\n        if (!HttpService.instance) {\n            HttpService.instance = new HttpService(baseUrl);\n        }\n        return HttpService.instance;\n    }\n    static resetInstance() {\n        HttpService.instance = null;\n    }\n    // ------------------- Public methods -------------------------\n    cancelRequest(requestId) {\n        const controller = this.activeRequests.get(requestId);\n        if (controller) {\n            controller.abort();\n            this.activeRequests.delete(requestId);\n        }\n    }\n    cancelAllRequests() {\n        this.activeRequests.forEach((controller)=>controller.abort());\n        this.activeRequests.clear();\n    }\n    // ------------------------------------------------------------\n    // ------------------ Private methods -------------------------\n    generateRequestId() {\n        let prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'req';\n        this.requestCounter++;\n        return \"\".concat(prefix, \"_\").concat(Date.now(), \"_\").concat(this.requestCounter);\n    }\n    async handleResponse(response) {\n        if (!response.ok) {\n            // Try to get error message from response body\n            let errorMessage;\n            let errorType;\n            try {\n                const contentType = response.headers.get('content-type');\n                if (contentType && contentType.includes('application/json')) {\n                    const errorData = await response.json();\n                    errorMessage = errorData.message || errorData.error;\n                    const headerErrorType = response.headers.get('x-amzn-ErrorType') || response.headers.get('x-amzn-errortype');\n                    const bodyErrorType = errorData.__type;\n                    const rawType = headerErrorType || bodyErrorType;\n                    if (rawType) {\n                        // Some AWS error types come as \"Type:detail\"; we only want the type prefix\n                        errorType = String(rawType).split(':')[0];\n                    }\n                } else {\n                    errorMessage = await response.text();\n                }\n            } catch (e) {\n                // If we can't parse the error response, use default message\n                errorMessage = undefined;\n            }\n            throw new _types_httpError__WEBPACK_IMPORTED_MODULE_1__.HttpError({\n                code: response.status,\n                message: errorMessage,\n                type: errorType\n            });\n        }\n        const contentType = response.headers.get('content-type');\n        if (contentType && contentType.includes('application/json')) {\n            return response.json();\n        }\n        return response.text();\n    }\n    buildUrl(path, params) {\n        const url = new URL(\"\".concat(this.baseUrl).concat(path));\n        if (params) {\n            Object.entries(params).forEach((param)=>{\n                let [key, value] = param;\n                url.searchParams.append(key, value);\n            });\n        }\n        return url.toString();\n    }\n    createRequestController(requestId) {\n        this.cancelRequest(requestId);\n        const controller = new AbortController();\n        this.activeRequests.set(requestId, controller);\n        return controller;\n    }\n    /**\n     * Perform a fetch call and on 401 try to refresh the session and retry once.\n     * If refresh or retry fails, perform a global logout and rethrow the error.\n     */ async performFetchWithAuthRetry(url, init) {\n        try {\n            const response = await fetch(url, init);\n            return await this.handleResponse(response);\n        } catch (error) {\n            if (error instanceof _types_httpError__WEBPACK_IMPORTED_MODULE_1__.HttpError && error.code === 401) {\n                try {\n                    await (0,aws_amplify_auth__WEBPACK_IMPORTED_MODULE_3__.fetchAuthSession)({\n                        forceRefresh: true\n                    });\n                    const refreshedHeaders = await this.addAuthHeaders(init.headers || {}, url);\n                    const retryResponse = await fetch(url, {\n                        ...init,\n                        headers: refreshedHeaders\n                    });\n                    return await this.handleResponse(retryResponse);\n                } catch (retryError) {\n                    try {\n                        await _services_authService__WEBPACK_IMPORTED_MODULE_2__.authService.logout();\n                    } catch (e) {\n                    // Ignore logout errors; we'll still redirect via global error handling\n                    }\n                    // Prefer throwing the retry error if it's an HttpError, else rethrow original\n                    if (retryError instanceof _types_httpError__WEBPACK_IMPORTED_MODULE_1__.HttpError) {\n                        throw retryError;\n                    }\n                    throw error;\n                }\n            }\n            throw error;\n        }\n    }\n    /**\n     * Interceptor that adds authorization headers to requests\n     * Skips auth header for public endpoints and S3 URLs\n     */ async addAuthHeaders(headers, url) {\n        var _session_tokens_accessToken, _session_tokens;\n        // Skip auth header for public endpoints and S3 URLs\n        if (url.includes('/auth') || url.includes('/public') || url.includes('s3.')) {\n            return headers;\n        }\n        const session = await (0,aws_amplify_auth__WEBPACK_IMPORTED_MODULE_3__.fetchAuthSession)();\n        const token = (_session_tokens = session.tokens) === null || _session_tokens === void 0 ? void 0 : (_session_tokens_accessToken = _session_tokens.accessToken) === null || _session_tokens_accessToken === void 0 ? void 0 : _session_tokens_accessToken.toString();\n        if (token) {\n            return {\n                ...headers,\n                'Authorization': \"Bearer \".concat(token)\n            };\n        }\n        return headers;\n    }\n    // ------------------------------------------------------------\n    // ----------------- Generic API calls ------------------------\n    async get(path) {\n        let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const requestId = this.generateRequestId(\"get_\".concat(path));\n        const controller = this.createRequestController(requestId);\n        const signal = config.signal || controller.signal;\n        const url = this.buildUrl(path, config.params);\n        return _loadingService__WEBPACK_IMPORTED_MODULE_0__.LoadingService.withLoading((async ()=>{\n            try {\n                const headers = await this.addAuthHeaders({\n                    ...this.defaultHeaders,\n                    ...config.headers\n                }, url);\n                return await this.performFetchWithAuthRetry(url, {\n                    method: 'GET',\n                    headers,\n                    signal\n                });\n            } finally{\n                this.activeRequests.delete(requestId);\n            }\n        })(), requestId);\n    }\n    async post(path) {\n        let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const requestId = this.generateRequestId(\"post_\".concat(path));\n        const controller = this.createRequestController(requestId);\n        const signal = config.signal || controller.signal;\n        const url = this.buildUrl(path, config.params);\n        return _loadingService__WEBPACK_IMPORTED_MODULE_0__.LoadingService.withLoading((async ()=>{\n            try {\n                const headers = await this.addAuthHeaders({\n                    ...this.defaultHeaders,\n                    ...config.headers\n                }, url);\n                return await this.performFetchWithAuthRetry(url, {\n                    method: 'POST',\n                    headers,\n                    signal,\n                    body: config.body ? JSON.stringify(config.body) : undefined\n                });\n            } finally{\n                this.activeRequests.delete(requestId);\n            }\n        })(), requestId);\n    }\n    async put(path) {\n        let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const requestId = this.generateRequestId(\"put_\".concat(path));\n        const controller = this.createRequestController(requestId);\n        const signal = config.signal || controller.signal;\n        const url = this.buildUrl(path, config.params);\n        return _loadingService__WEBPACK_IMPORTED_MODULE_0__.LoadingService.withLoading((async ()=>{\n            try {\n                const headers = await this.addAuthHeaders({\n                    ...this.defaultHeaders,\n                    ...config.headers\n                }, url);\n                return await this.performFetchWithAuthRetry(url, {\n                    method: 'PUT',\n                    headers,\n                    signal,\n                    body: config.body ? JSON.stringify(config.body) : undefined\n                });\n            } finally{\n                this.activeRequests.delete(requestId);\n            }\n        })(), requestId);\n    }\n    async delete(path) {\n        let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const requestId = this.generateRequestId(\"delete_\".concat(path));\n        const controller = this.createRequestController(requestId);\n        const signal = config.signal || controller.signal;\n        const url = this.buildUrl(path, config.params);\n        return _loadingService__WEBPACK_IMPORTED_MODULE_0__.LoadingService.withLoading((async ()=>{\n            try {\n                const headers = await this.addAuthHeaders({\n                    ...this.defaultHeaders,\n                    ...config.headers\n                }, url);\n                return await this.performFetchWithAuthRetry(url, {\n                    method: 'DELETE',\n                    headers,\n                    signal\n                });\n            } finally{\n                this.activeRequests.delete(requestId);\n            }\n        })(), requestId);\n    }\n    // ------------------------------------------------------------\n    // ----------------- Custom API calls -------------------------\n    async getUser() {\n        return await this.get('/user');\n    }\n    async updateUser(user) {\n        return await this.put('/user', {\n            body: user\n        });\n    }\n    async getAllCases() {\n        return await this.get('/case');\n    }\n    async getCaseById(id) {\n        return await this.get(\"/case/\".concat(id));\n    }\n    async createCase(caseData) {\n        return await this.post('/case', {\n            body: caseData\n        });\n    }\n    async updateCase(id, caseData) {\n        return await this.put(\"/case/\".concat(id), {\n            body: caseData\n        });\n    }\n    async sendOffer(params, payload) {\n        return await this.post(\"/admin/send-offer\", {\n            params,\n            body: payload\n        });\n    }\n    async acceptOffer(caseId) {\n        return await this.get(\"/case/\".concat(caseId, \"/accept-offer\"));\n    }\n    async getWorkInProcessCases() {\n        return await this.get('/case/work-in-process');\n    }\n    async getWaitingForUserCases() {\n        return await this.get('/case/waiting-for-user');\n    }\n    async getCasesByStatus(statusList) {\n        return await this.get('/case/by-status', {\n            params: {\n                statusList: statusList.join(',')\n            }\n        });\n    }\n    async createAttachment(payload) {\n        return await this.post(\"/case/attachment\", {\n            body: payload\n        });\n    }\n    async getAttachmentUrl(params) {\n        return await this.get(\"/case/attachment\", {\n            params: {\n                attachmentId: params.attachmentId,\n                caseId: String(params.caseId)\n            }\n        });\n    }\n    async deleteAttachment(params) {\n        const qp = {\n            attachmentId: params.attachmentId\n        };\n        if (typeof params.caseId === 'number') {\n            qp.caseId = String(params.caseId);\n        }\n        return await this.delete(\"/case/attachment\", {\n            params: qp\n        });\n    }\n    async getDocumentUrl(params) {\n        return await this.get(\"/case/document\", {\n            params\n        });\n    }\n    async markInvoicePaid(params) {\n        return await this.post(\"/admin/invoice-paid\", {\n            params\n        });\n    }\n    async suggestAppointment(payload) {\n        return await this.post(\"/admin/suggest-appointment\", {\n            body: payload\n        });\n    }\n    async getAllDoctors(filters) {\n        const params = {};\n        Object.entries(filters).forEach((param)=>{\n            let [key, value] = param;\n            if (value !== undefined) {\n                params[key] = String(value);\n            }\n        });\n        return await this.get('/doctor', {\n            params\n        });\n    }\n    async getDoctorSelf() {\n        return await this.get('/doctor/self');\n    }\n    async upsertDoctor(doctor, queryParams) {\n        return await this.post('/doctor', {\n            body: doctor,\n            params: queryParams\n        });\n    }\n    async deleteDoctor(id) {\n        return await this.delete(\"/doctor\", {\n            params: {\n                id: id\n            }\n        });\n    }\n    async getAllSpecialties() {\n        return await this.get('/admin/specialty');\n    }\n    async upsertSpecialty(specialty) {\n        return await this.post('/admin/specialty', {\n            body: specialty\n        });\n    }\n    async deleteSpecialty(id) {\n        return await this.delete(\"/admin/specialty\", {\n            params: {\n                id: id\n            }\n        });\n    }\n    async getAllSubspecialties(specialtyId) {\n        return await this.get('/admin/subspecialty', {\n            params: {\n                specialtyId: String(specialtyId)\n            }\n        });\n    }\n    async upsertSubspecialty(subspecialty, specialtyId) {\n        return await this.post('/admin/subspecialty', {\n            body: subspecialty,\n            params: {\n                specialtyId: String(specialtyId)\n            }\n        });\n    }\n    async deleteSubspecialty(id) {\n        return await this.delete(\"/admin/subspecialty\", {\n            params: {\n                id: id\n            }\n        });\n    }\n    async acceptAppointment(appointmentId, caseId) {\n        return await this.get(\"/case/appointment\", {\n            params: {\n                appointmentId: appointmentId,\n                caseId: caseId\n            }\n        });\n    }\n    async declineAppointment(caseId) {\n        return await this.delete(\"/case/appointment\", {\n            params: {\n                caseId: caseId\n            }\n        });\n    }\n    constructor(baseUrl){\n        this.requestCounter = 0;\n        if (!baseUrl && !API_BASE_URL) {\n            throw new Error('API base URL is not configured. Please set NEXT_PUBLIC_API_BASE_URL in your .env file');\n        }\n        this.baseUrl = baseUrl || API_BASE_URL;\n        this.defaultHeaders = {\n            'Content-Type': 'application/json'\n        };\n        this.activeRequests = new Map();\n    }\n}\nHttpService.instance = null;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QzVILE9BQU8sR0FBR0EsV0FBV047UUFDMUIsSUFBSSxDQUFDOEUsY0FBYyxHQUFHO1lBQ2xCLGdCQUFnQjtRQUNwQjtRQUNBLElBQUksQ0FBQ2xFLGNBQWMsR0FBRyxJQUFJdUg7SUFDOUI7QUFtWUo7QUFuWmEvSCxZQUNNRyxXQUErQiIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9zcmMvc2VydmljZXMvaHR0cFNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGluZ1NlcnZpY2UgfSBmcm9tICcuL2xvYWRpbmdTZXJ2aWNlJztcbmltcG9ydCB7IFVzZXIgfSBmcm9tICdAL3R5cGVzL3VzZXInO1xuaW1wb3J0IHsgSHR0cEVycm9yLCBIdHRwRXJyb3JDb2RlIH0gZnJvbSAnQC90eXBlcy9odHRwRXJyb3InO1xuaW1wb3J0IHsgZmV0Y2hBdXRoU2Vzc2lvbiB9IGZyb20gJ2F3cy1hbXBsaWZ5L2F1dGgnO1xuaW1wb3J0IHsgYXV0aFNlcnZpY2UgfSBmcm9tICdAL3NlcnZpY2VzL2F1dGhTZXJ2aWNlJztcbmltcG9ydCB7IENhc2UsIENhc2VMaXN0UGFnaW5hdGVkUmVzcG9uc2UgfSBmcm9tICdAL3R5cGVzL2Nhc2UnO1xuaW1wb3J0IHsgQ2FzZVN0YXR1cyB9IGZyb20gJ0AvdHlwZXMvc3RhdHVzJztcbmltcG9ydCB7IEFwcG9pbnRtZW50TGlzdCB9IGZyb20gJ0AvdHlwZXMvYXBwb2ludG1lbnQnO1xuaW1wb3J0IHsgRG9jdG9yRmlsdGVycywgRG9jdG9yUHJvZmlsZSwgUGFnaW5hdGVkRG9jdG9yUmVzcG9uc2UsIFNwZWNpYWx0eSwgU3Vic3BlY2lhbHR5IH0gZnJvbSAnQC90eXBlcyc7XG5cbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkw7XG5cbnR5cGUgSHR0cEhlYWRlcnMgPSBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG5pbnRlcmZhY2UgUmVxdWVzdENvbmZpZyB7XG4gICAgaGVhZGVycz86IEh0dHBIZWFkZXJzO1xuICAgIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgc2lnbmFsPzogQWJvcnRTaWduYWw7XG59XG5cbmludGVyZmFjZSBSZXF1ZXN0Q29uZmlnV2l0aEJvZHkgZXh0ZW5kcyBSZXF1ZXN0Q29uZmlnIHtcbiAgICBib2R5PzogdW5rbm93bjtcbn1cblxuZXhwb3J0IGNsYXNzIEh0dHBTZXJ2aWNlIHtcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogSHR0cFNlcnZpY2UgfCBudWxsID0gbnVsbDtcbiAgICBwcml2YXRlIGJhc2VVcmw6IHN0cmluZztcbiAgICBwcml2YXRlIGRlZmF1bHRIZWFkZXJzOiBIdHRwSGVhZGVycztcbiAgICBwcml2YXRlIGFjdGl2ZVJlcXVlc3RzOiBNYXA8c3RyaW5nLCBBYm9ydENvbnRyb2xsZXI+O1xuICAgIHByaXZhdGUgcmVxdWVzdENvdW50ZXI6IG51bWJlciA9IDA7XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKGJhc2VVcmw/OiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKCFiYXNlVXJsICYmICFBUElfQkFTRV9VUkwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQVBJIGJhc2UgVVJMIGlzIG5vdCBjb25maWd1cmVkLiBQbGVhc2Ugc2V0IE5FWFRfUFVCTElDX0FQSV9CQVNFX1VSTCBpbiB5b3VyIC5lbnYgZmlsZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmwgfHwgQVBJX0JBU0VfVVJMITtcbiAgICAgICAgdGhpcy5kZWZhdWx0SGVhZGVycyA9IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZShiYXNlVXJsPzogc3RyaW5nKTogSHR0cFNlcnZpY2Uge1xuICAgICAgICBpZiAoIUh0dHBTZXJ2aWNlLmluc3RhbmNlKSB7XG4gICAgICAgICAgICBIdHRwU2VydmljZS5pbnN0YW5jZSA9IG5ldyBIdHRwU2VydmljZShiYXNlVXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSHR0cFNlcnZpY2UuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyByZXNldEluc3RhbmNlKCk6IHZvaWQge1xuICAgICAgICBIdHRwU2VydmljZS5pbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLSBQdWJsaWMgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcHVibGljIGNhbmNlbFJlcXVlc3QocmVxdWVzdElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuYWN0aXZlUmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGNhbmNlbEFsbFJlcXVlc3RzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFjdGl2ZVJlcXVlc3RzLmZvckVhY2goY29udHJvbGxlciA9PiBjb250cm9sbGVyLmFib3J0KCkpO1xuICAgICAgICB0aGlzLmFjdGl2ZVJlcXVlc3RzLmNsZWFyKCk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tIFByaXZhdGUgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZVJlcXVlc3RJZChwcmVmaXg6IHN0cmluZyA9ICdyZXEnKTogc3RyaW5nIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q291bnRlcisrO1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fV8ke0RhdGUubm93KCl9XyR7dGhpcy5yZXF1ZXN0Q291bnRlcn1gO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgaGFuZGxlUmVzcG9uc2U8VD4ocmVzcG9uc2U6IFJlc3BvbnNlKTogUHJvbWlzZTxUPiB7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBnZXQgZXJyb3IgbWVzc2FnZSBmcm9tIHJlc3BvbnNlIGJvZHlcbiAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBlcnJvclR5cGU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckVycm9yVHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LWFtem4tRXJyb3JUeXBlJykgfHwgcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtYW16bi1lcnJvcnR5cGUnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keUVycm9yVHlwZSA9IGVycm9yRGF0YS5fX3R5cGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd1R5cGU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IGhlYWRlckVycm9yVHlwZSB8fCBib2R5RXJyb3JUeXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmF3VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZSBBV1MgZXJyb3IgdHlwZXMgY29tZSBhcyBcIlR5cGU6ZGV0YWlsXCI7IHdlIG9ubHkgd2FudCB0aGUgdHlwZSBwcmVmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yVHlwZSA9IFN0cmluZyhyYXdUeXBlKS5zcGxpdCgnOicpWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IHBhcnNlIHRoZSBlcnJvciByZXNwb25zZSwgdXNlIGRlZmF1bHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEh0dHBFcnJvcih7IFxuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3BvbnNlLnN0YXR1cyBhcyBIdHRwRXJyb3JDb2RlLCBcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgdHlwZTogZXJyb3JUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKSBhcyBQcm9taXNlPFQ+O1xuICAgIH1cblxuICAgIHByaXZhdGUgYnVpbGRVcmwocGF0aDogc3RyaW5nLCBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLmJhc2VVcmx9JHtwYXRofWApO1xuICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlUmVxdWVzdENvbnRyb2xsZXIocmVxdWVzdElkOiBzdHJpbmcpOiBBYm9ydENvbnRyb2xsZXIge1xuICAgICAgICB0aGlzLmNhbmNlbFJlcXVlc3QocmVxdWVzdElkKTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5hY3RpdmVSZXF1ZXN0cy5zZXQocmVxdWVzdElkLCBjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIGZldGNoIGNhbGwgYW5kIG9uIDQwMSB0cnkgdG8gcmVmcmVzaCB0aGUgc2Vzc2lvbiBhbmQgcmV0cnkgb25jZS5cbiAgICAgKiBJZiByZWZyZXNoIG9yIHJldHJ5IGZhaWxzLCBwZXJmb3JtIGEgZ2xvYmFsIGxvZ291dCBhbmQgcmV0aHJvdyB0aGUgZXJyb3IuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtRmV0Y2hXaXRoQXV0aFJldHJ5PFQ+KHVybDogc3RyaW5nLCBpbml0OiBSZXF1ZXN0SW5pdCk6IFByb21pc2U8VD4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIGluaXQpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlUmVzcG9uc2U8VD4ocmVzcG9uc2UpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSHR0cEVycm9yICYmIGVycm9yLmNvZGUgPT09IDQwMSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGZldGNoQXV0aFNlc3Npb24oeyBmb3JjZVJlZnJlc2g6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hlZEhlYWRlcnMgPSBhd2FpdCB0aGlzLmFkZEF1dGhIZWFkZXJzKChpbml0LmhlYWRlcnMgYXMgSHR0cEhlYWRlcnMpIHx8IHt9LCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeVJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7IC4uLmluaXQsIGhlYWRlcnM6IHJlZnJlc2hlZEhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZVJlc3BvbnNlPFQ+KHJldHJ5UmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHJldHJ5RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGF1dGhTZXJ2aWNlLmxvZ291dCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBsb2dvdXQgZXJyb3JzOyB3ZSdsbCBzdGlsbCByZWRpcmVjdCB2aWEgZ2xvYmFsIGVycm9yIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJlZmVyIHRocm93aW5nIHRoZSByZXRyeSBlcnJvciBpZiBpdCdzIGFuIEh0dHBFcnJvciwgZWxzZSByZXRocm93IG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXRyeUVycm9yIGluc3RhbmNlb2YgSHR0cEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByZXRyeUVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJjZXB0b3IgdGhhdCBhZGRzIGF1dGhvcml6YXRpb24gaGVhZGVycyB0byByZXF1ZXN0c1xuICAgICAqIFNraXBzIGF1dGggaGVhZGVyIGZvciBwdWJsaWMgZW5kcG9pbnRzIGFuZCBTMyBVUkxzXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBhZGRBdXRoSGVhZGVycyhoZWFkZXJzOiBIdHRwSGVhZGVycywgdXJsOiBzdHJpbmcpOiBQcm9taXNlPEh0dHBIZWFkZXJzPiB7XG4gICAgICAgIC8vIFNraXAgYXV0aCBoZWFkZXIgZm9yIHB1YmxpYyBlbmRwb2ludHMgYW5kIFMzIFVSTHNcbiAgICAgICAgaWYgKHVybC5pbmNsdWRlcygnL2F1dGgnKSB8fCB1cmwuaW5jbHVkZXMoJy9wdWJsaWMnKSB8fCB1cmwuaW5jbHVkZXMoJ3MzLicpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBmZXRjaEF1dGhTZXNzaW9uKCk7XG4gICAgICAgIGNvbnN0IHRva2VuID0gc2Vzc2lvbi50b2tlbnM/LmFjY2Vzc1Rva2VuPy50b1N0cmluZygpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tIEdlbmVyaWMgQVBJIGNhbGxzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGdldDxUPihwYXRoOiBzdHJpbmcsIGNvbmZpZzogUmVxdWVzdENvbmZpZyA9IHt9KTogUHJvbWlzZTxUPiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHRoaXMuZ2VuZXJhdGVSZXF1ZXN0SWQoYGdldF8ke3BhdGh9YCk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZVJlcXVlc3RDb250cm9sbGVyKHJlcXVlc3RJZCk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IGNvbmZpZy5zaWduYWwgfHwgY29udHJvbGxlci5zaWduYWw7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRVcmwocGF0aCwgY29uZmlnLnBhcmFtcyk7XG5cbiAgICAgICAgcmV0dXJuIExvYWRpbmdTZXJ2aWNlLndpdGhMb2FkaW5nKFxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgdGhpcy5hZGRBdXRoSGVhZGVycyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmRlZmF1bHRIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH0sIHVybCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucGVyZm9ybUZldGNoV2l0aEF1dGhSZXRyeTxUPih1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCksXG4gICAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBhc3luYyBwb3N0PFQ+KHBhdGg6IHN0cmluZywgY29uZmlnOiBSZXF1ZXN0Q29uZmlnV2l0aEJvZHkgPSB7fSk6IFByb21pc2U8VD4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSB0aGlzLmdlbmVyYXRlUmVxdWVzdElkKGBwb3N0XyR7cGF0aH1gKTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY3JlYXRlUmVxdWVzdENvbnRyb2xsZXIocmVxdWVzdElkKTtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gY29uZmlnLnNpZ25hbCB8fCBjb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFVybChwYXRoLCBjb25maWcucGFyYW1zKTtcblxuICAgICAgICByZXR1cm4gTG9hZGluZ1NlcnZpY2Uud2l0aExvYWRpbmcoXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCB0aGlzLmFkZEF1dGhIZWFkZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZGVmYXVsdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jb25maWcuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfSwgdXJsKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJmb3JtRmV0Y2hXaXRoQXV0aFJldHJ5PFQ+KHVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogY29uZmlnLmJvZHkgPyBKU09OLnN0cmluZ2lmeShjb25maWcuYm9keSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKSxcbiAgICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGFzeW5jIHB1dDxUPihwYXRoOiBzdHJpbmcsIGNvbmZpZzogUmVxdWVzdENvbmZpZ1dpdGhCb2R5ID0ge30pOiBQcm9taXNlPFQ+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gdGhpcy5nZW5lcmF0ZVJlcXVlc3RJZChgcHV0XyR7cGF0aH1gKTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY3JlYXRlUmVxdWVzdENvbnRyb2xsZXIocmVxdWVzdElkKTtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gY29uZmlnLnNpZ25hbCB8fCBjb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFVybChwYXRoLCBjb25maWcucGFyYW1zKTtcblxuICAgICAgICByZXR1cm4gTG9hZGluZ1NlcnZpY2Uud2l0aExvYWRpbmcoXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCB0aGlzLmFkZEF1dGhIZWFkZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZGVmYXVsdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jb25maWcuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfSwgdXJsKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJmb3JtRmV0Y2hXaXRoQXV0aFJldHJ5PFQ+KHVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBjb25maWcuYm9keSA/IEpTT04uc3RyaW5naWZ5KGNvbmZpZy5ib2R5KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVSZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpLFxuICAgICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlPFQ+KHBhdGg6IHN0cmluZywgY29uZmlnOiBSZXF1ZXN0Q29uZmlnID0ge30pOiBQcm9taXNlPFQ+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gdGhpcy5nZW5lcmF0ZVJlcXVlc3RJZChgZGVsZXRlXyR7cGF0aH1gKTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY3JlYXRlUmVxdWVzdENvbnRyb2xsZXIocmVxdWVzdElkKTtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gY29uZmlnLnNpZ25hbCB8fCBjb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFVybChwYXRoLCBjb25maWcucGFyYW1zKTtcblxuICAgICAgICByZXR1cm4gTG9hZGluZ1NlcnZpY2Uud2l0aExvYWRpbmcoXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCB0aGlzLmFkZEF1dGhIZWFkZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZGVmYXVsdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jb25maWcuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfSwgdXJsKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJmb3JtRmV0Y2hXaXRoQXV0aFJldHJ5PFQ+KHVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKSxcbiAgICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICApO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tIEN1c3RvbSBBUEkgY2FsbHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgYXN5bmMgZ2V0VXNlcigpOiBQcm9taXNlPFVzZXI+IHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldDxVc2VyPignL3VzZXInKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgdXBkYXRlVXNlcih1c2VyOiBVc2VyKTogUHJvbWlzZTxVc2VyPiB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wdXQ8VXNlcj4oJy91c2VyJywgeyBib2R5OiB1c2VyIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRBbGxDYXNlcygpOiBQcm9taXNlPENhc2VMaXN0UGFnaW5hdGVkUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldDxDYXNlTGlzdFBhZ2luYXRlZFJlc3BvbnNlPignL2Nhc2UnKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0Q2FzZUJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8Q2FzZT4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0PENhc2U+KGAvY2FzZS8ke2lkfWApKTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVDYXNlKGNhc2VEYXRhOiB7IGhhc19kaWFnbm9zaXM/OiBib29sZWFuOyBzeW1wdG9tcz86IEFycmF5PHsgZGVzY3JpcHRpb246IHN0cmluZzsgZHVyYXRpb246IHN0cmluZzsgc2V2ZXJpdHk6IHN0cmluZzsgY3VzdG9tX25vdGVzPzogc3RyaW5nIHwgbnVsbCB9PjsgY3VzdG9tX25vdGVzPzogc3RyaW5nIHwgbnVsbDsgYXR0YWNobWVudHM/OiBBcnJheTx7IGlkOiBudW1iZXI7IG9yaWdpbmFsTmFtZT86IHN0cmluZyB8IG51bGw7IHR5cGU6IHsgbmFtZTogc3RyaW5nIH0gfT4gfSk6IFByb21pc2U8Q2FzZT4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucG9zdDxDYXNlPignL2Nhc2UnLCB7IGJvZHk6IGNhc2VEYXRhIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyB1cGRhdGVDYXNlKGlkOiBzdHJpbmcsIGNhc2VEYXRhOiBDYXNlKTogUHJvbWlzZTxDYXNlPiB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wdXQ8Q2FzZT4oYC9jYXNlLyR7aWR9YCwgeyBib2R5OiBjYXNlRGF0YSB9KSk7XG4gICAgfVxuXG4gICAgYXN5bmMgc2VuZE9mZmVyKHBhcmFtczogeyBjYXNlSWQ6IHN0cmluZyB9LCBwYXlsb2FkOiB7IHRleHQ6IHN0cmluZzsgYW1vdW50X2dyb3NzOiBudW1iZXIgfSk6IFByb21pc2U8Q2FzZT4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucG9zdDxDYXNlPihgL2FkbWluL3NlbmQtb2ZmZXJgLCB7IHBhcmFtcywgYm9keTogcGF5bG9hZCB9KSk7XG4gICAgfVxuXG4gICAgYXN5bmMgYWNjZXB0T2ZmZXIoY2FzZUlkOiBzdHJpbmcpOiBQcm9taXNlPENhc2U+IHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldDxDYXNlPihgL2Nhc2UvJHtjYXNlSWR9L2FjY2VwdC1vZmZlcmApKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRXb3JrSW5Qcm9jZXNzQ2FzZXMoKTogUHJvbWlzZTxDYXNlTGlzdFBhZ2luYXRlZFJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXQ8Q2FzZUxpc3RQYWdpbmF0ZWRSZXNwb25zZT4oJy9jYXNlL3dvcmstaW4tcHJvY2VzcycpKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRXYWl0aW5nRm9yVXNlckNhc2VzKCk6IFByb21pc2U8Q2FzZUxpc3RQYWdpbmF0ZWRSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0PENhc2VMaXN0UGFnaW5hdGVkUmVzcG9uc2U+KCcvY2FzZS93YWl0aW5nLWZvci11c2VyJykpO1xuICAgIH1cblxuICAgIGFzeW5jIGdldENhc2VzQnlTdGF0dXMoc3RhdHVzTGlzdDogQ2FzZVN0YXR1c1tdKTogUHJvbWlzZTxDYXNlTGlzdFBhZ2luYXRlZFJlc3BvbnNlPiB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXQ8Q2FzZUxpc3RQYWdpbmF0ZWRSZXNwb25zZT4oJy9jYXNlL2J5LXN0YXR1cycsIHsgcGFyYW1zOiB7IHN0YXR1c0xpc3Q6IHN0YXR1c0xpc3Quam9pbignLCcpIH0gfSkpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZUF0dGFjaG1lbnQocGF5bG9hZDogeyBjYXNlSWQ/OiBudW1iZXI7IG9yaWdpbmFsTmFtZT86IHN0cmluZyB8IG51bGw7IHVybD86IHN0cmluZyB8IG51bGw7IGRlc2NyaXB0aW9uPzogc3RyaW5nIHwgbnVsbDsgdHlwZT86IHsgbmFtZTogc3RyaW5nIH0gfCBudWxsOyBpc19kaWFnbm9zaXM/OiBib29sZWFuIH0pOiBQcm9taXNlPHsgdXJsPzogc3RyaW5nIHwgbnVsbDsgYXR0YWNobWVudElkPzogbnVtYmVyIH0+IHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnBvc3Q8eyB1cmw/OiBzdHJpbmcgfCBudWxsOyBhdHRhY2htZW50SWQ/OiBudW1iZXIgfT4oYC9jYXNlL2F0dGFjaG1lbnRgLCB7IGJvZHk6IHBheWxvYWQgfSkpO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEF0dGFjaG1lbnRVcmwocGFyYW1zOiB7IGF0dGFjaG1lbnRJZDogc3RyaW5nOyBjYXNlSWQ6IG51bWJlciB9KTogUHJvbWlzZTx7IHVybDogc3RyaW5nIH0+IHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldDx7IHVybDogc3RyaW5nIH0+KGAvY2FzZS9hdHRhY2htZW50YCwgeyBwYXJhbXM6IHsgYXR0YWNobWVudElkOiBwYXJhbXMuYXR0YWNobWVudElkLCBjYXNlSWQ6IFN0cmluZyhwYXJhbXMuY2FzZUlkKSB9IH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBkZWxldGVBdHRhY2htZW50KHBhcmFtczogeyBhdHRhY2htZW50SWQ6IHN0cmluZzsgY2FzZUlkPzogbnVtYmVyIHwgbnVsbCB9KTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gICAgICAgIGNvbnN0IHFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0geyBhdHRhY2htZW50SWQ6IHBhcmFtcy5hdHRhY2htZW50SWQgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuY2FzZUlkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcXAuY2FzZUlkID0gU3RyaW5nKHBhcmFtcy5jYXNlSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5kZWxldGU8eyBtZXNzYWdlOiBzdHJpbmcgfT4oYC9jYXNlL2F0dGFjaG1lbnRgLCB7IHBhcmFtczogcXAgfSkpO1xuICAgIH1cblxuICAgIGFzeW5jIGdldERvY3VtZW50VXJsKHBhcmFtczogeyBjYXNlSWQ6IHN0cmluZzsgZG9jVHlwZTogc3RyaW5nIH0pOiBQcm9taXNlPHsgdXJsOiBzdHJpbmcgfT4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0PHsgdXJsOiBzdHJpbmcgfT4oYC9jYXNlL2RvY3VtZW50YCwgeyBwYXJhbXMgfSkpO1xuICAgIH1cblxuICAgIGFzeW5jIG1hcmtJbnZvaWNlUGFpZChwYXJhbXM6IHsgY2FzZUlkOiBzdHJpbmcgfSk6IFByb21pc2U8Q2FzZT4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucG9zdDxDYXNlPihgL2FkbWluL2ludm9pY2UtcGFpZGAsIHsgcGFyYW1zIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBzdWdnZXN0QXBwb2ludG1lbnQocGF5bG9hZDogeyBjYXNlSWQ6IG51bWJlcjsgZG9jdG9ySWQ6IG51bWJlcjsgc3VnZ2VzdGVkQXBwb2ludG1lbnRzOiBBcHBvaW50bWVudExpc3QgfSk6IFByb21pc2U8Q2FzZT4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucG9zdDxDYXNlPihgL2FkbWluL3N1Z2dlc3QtYXBwb2ludG1lbnRgLCB7IGJvZHk6IHBheWxvYWQgfSkpO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEFsbERvY3RvcnMoZmlsdGVyczogRG9jdG9yRmlsdGVycyk6IFByb21pc2U8UGFnaW5hdGVkRG9jdG9yUmVzcG9uc2U+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5XSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0PFBhZ2luYXRlZERvY3RvclJlc3BvbnNlPignL2RvY3RvcicsIHsgcGFyYW1zIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXREb2N0b3JTZWxmKCk6IFByb21pc2U8RG9jdG9yUHJvZmlsZT4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0PERvY3RvclByb2ZpbGU+KCcvZG9jdG9yL3NlbGYnKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgdXBzZXJ0RG9jdG9yKGRvY3RvcjogRG9jdG9yUHJvZmlsZSwgcXVlcnlQYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogUHJvbWlzZTxEb2N0b3JQcm9maWxlPiB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wb3N0PERvY3RvclByb2ZpbGU+KCcvZG9jdG9yJywgeyBib2R5OiBkb2N0b3IsIHBhcmFtczogcXVlcnlQYXJhbXMgfSkpO1xuICAgIH1cblxuICAgIGFzeW5jIGRlbGV0ZURvY3RvcihpZDogc3RyaW5nKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5kZWxldGU8eyBtZXNzYWdlOiBzdHJpbmcgfT4oYC9kb2N0b3JgLCB7IHBhcmFtczogeyBpZDogaWQgfSB9KSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QWxsU3BlY2lhbHRpZXMoKTogUHJvbWlzZTxTcGVjaWFsdHlbXT4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0PFNwZWNpYWx0eVtdPignL2FkbWluL3NwZWNpYWx0eScpKTtcbiAgICB9XG5cbiAgICBhc3luYyB1cHNlcnRTcGVjaWFsdHkoc3BlY2lhbHR5OiBTcGVjaWFsdHkpOiBQcm9taXNlPFNwZWNpYWx0eT4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucG9zdDxTcGVjaWFsdHk+KCcvYWRtaW4vc3BlY2lhbHR5JywgeyBib2R5OiBzcGVjaWFsdHkgfSkpO1xuICAgIH1cblxuICAgIGFzeW5jIGRlbGV0ZVNwZWNpYWx0eShpZDogc3RyaW5nKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5kZWxldGU8eyBtZXNzYWdlOiBzdHJpbmcgfT4oYC9hZG1pbi9zcGVjaWFsdHlgLCB7IHBhcmFtczogeyBpZDogaWQgfSB9KSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QWxsU3Vic3BlY2lhbHRpZXMoc3BlY2lhbHR5SWQ6IG51bWJlcik6IFByb21pc2U8U3Vic3BlY2lhbHR5W10+IHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldDxTdWJzcGVjaWFsdHlbXT4oJy9hZG1pbi9zdWJzcGVjaWFsdHknLCB7IHBhcmFtczogeyBzcGVjaWFsdHlJZDogU3RyaW5nKHNwZWNpYWx0eUlkKSB9IH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyB1cHNlcnRTdWJzcGVjaWFsdHkoc3Vic3BlY2lhbHR5OiBTdWJzcGVjaWFsdHksIHNwZWNpYWx0eUlkOiBudW1iZXIpOiBQcm9taXNlPFN1YnNwZWNpYWx0eT4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucG9zdDxTdWJzcGVjaWFsdHk+KCcvYWRtaW4vc3Vic3BlY2lhbHR5JywgeyBib2R5OiBzdWJzcGVjaWFsdHksIHBhcmFtczogeyBzcGVjaWFsdHlJZDogU3RyaW5nKHNwZWNpYWx0eUlkKSB9IH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBkZWxldGVTdWJzcGVjaWFsdHkoaWQ6IHN0cmluZyk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZGVsZXRlPHsgbWVzc2FnZTogc3RyaW5nIH0+KGAvYWRtaW4vc3Vic3BlY2lhbHR5YCwgeyBwYXJhbXM6IHsgaWQ6IGlkIH0gfSkpO1xuICAgIH1cblxuICAgIGFzeW5jIGFjY2VwdEFwcG9pbnRtZW50KGFwcG9pbnRtZW50SWQ6IHN0cmluZywgY2FzZUlkOiBzdHJpbmcpOiBQcm9taXNlPENhc2U+IHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldDxDYXNlPihgL2Nhc2UvYXBwb2ludG1lbnRgLCB7IHBhcmFtczogeyBhcHBvaW50bWVudElkOiBhcHBvaW50bWVudElkLCBjYXNlSWQ6IGNhc2VJZCB9IH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBkZWNsaW5lQXBwb2ludG1lbnQoY2FzZUlkOiBzdHJpbmcpOiBQcm9taXNlPENhc2U+IHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmRlbGV0ZTxDYXNlPihgL2Nhc2UvYXBwb2ludG1lbnRgLCB7IHBhcmFtczogeyBjYXNlSWQ6IGNhc2VJZCB9IH0pKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbn0iXSwibmFtZXMiOlsiTG9hZGluZ1NlcnZpY2UiLCJIdHRwRXJyb3IiLCJmZXRjaEF1dGhTZXNzaW9uIiwiYXV0aFNlcnZpY2UiLCJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIkh0dHBTZXJ2aWNlIiwiZ2V0SW5zdGFuY2UiLCJiYXNlVXJsIiwiaW5zdGFuY2UiLCJyZXNldEluc3RhbmNlIiwiY2FuY2VsUmVxdWVzdCIsInJlcXVlc3RJZCIsImNvbnRyb2xsZXIiLCJhY3RpdmVSZXF1ZXN0cyIsImdldCIsImFib3J0IiwiZGVsZXRlIiwiY2FuY2VsQWxsUmVxdWVzdHMiLCJmb3JFYWNoIiwiY2xlYXIiLCJnZW5lcmF0ZVJlcXVlc3RJZCIsInByZWZpeCIsInJlcXVlc3RDb3VudGVyIiwiRGF0ZSIsIm5vdyIsImhhbmRsZVJlc3BvbnNlIiwicmVzcG9uc2UiLCJvayIsImVycm9yTWVzc2FnZSIsImVycm9yVHlwZSIsImNvbnRlbnRUeXBlIiwiaGVhZGVycyIsImluY2x1ZGVzIiwiZXJyb3JEYXRhIiwianNvbiIsIm1lc3NhZ2UiLCJlcnJvciIsImhlYWRlckVycm9yVHlwZSIsImJvZHlFcnJvclR5cGUiLCJfX3R5cGUiLCJyYXdUeXBlIiwiU3RyaW5nIiwic3BsaXQiLCJ0ZXh0IiwidW5kZWZpbmVkIiwiY29kZSIsInN0YXR1cyIsInR5cGUiLCJidWlsZFVybCIsInBhdGgiLCJwYXJhbXMiLCJ1cmwiLCJVUkwiLCJPYmplY3QiLCJlbnRyaWVzIiwia2V5IiwidmFsdWUiLCJzZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJ0b1N0cmluZyIsImNyZWF0ZVJlcXVlc3RDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwic2V0IiwicGVyZm9ybUZldGNoV2l0aEF1dGhSZXRyeSIsImluaXQiLCJmZXRjaCIsImZvcmNlUmVmcmVzaCIsInJlZnJlc2hlZEhlYWRlcnMiLCJhZGRBdXRoSGVhZGVycyIsInJldHJ5UmVzcG9uc2UiLCJyZXRyeUVycm9yIiwibG9nb3V0Iiwic2Vzc2lvbiIsInRva2VuIiwidG9rZW5zIiwiYWNjZXNzVG9rZW4iLCJjb25maWciLCJzaWduYWwiLCJ3aXRoTG9hZGluZyIsImRlZmF1bHRIZWFkZXJzIiwibWV0aG9kIiwicG9zdCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicHV0IiwiZ2V0VXNlciIsInVwZGF0ZVVzZXIiLCJ1c2VyIiwiZ2V0QWxsQ2FzZXMiLCJnZXRDYXNlQnlJZCIsImlkIiwiY3JlYXRlQ2FzZSIsImNhc2VEYXRhIiwidXBkYXRlQ2FzZSIsInNlbmRPZmZlciIsInBheWxvYWQiLCJhY2NlcHRPZmZlciIsImNhc2VJZCIsImdldFdvcmtJblByb2Nlc3NDYXNlcyIsImdldFdhaXRpbmdGb3JVc2VyQ2FzZXMiLCJnZXRDYXNlc0J5U3RhdHVzIiwic3RhdHVzTGlzdCIsImpvaW4iLCJjcmVhdGVBdHRhY2htZW50IiwiZ2V0QXR0YWNobWVudFVybCIsImF0dGFjaG1lbnRJZCIsImRlbGV0ZUF0dGFjaG1lbnQiLCJxcCIsImdldERvY3VtZW50VXJsIiwibWFya0ludm9pY2VQYWlkIiwic3VnZ2VzdEFwcG9pbnRtZW50IiwiZ2V0QWxsRG9jdG9ycyIsImZpbHRlcnMiLCJnZXREb2N0b3JTZWxmIiwidXBzZXJ0RG9jdG9yIiwiZG9jdG9yIiwicXVlcnlQYXJhbXMiLCJkZWxldGVEb2N0b3IiLCJnZXRBbGxTcGVjaWFsdGllcyIsInVwc2VydFNwZWNpYWx0eSIsInNwZWNpYWx0eSIsImRlbGV0ZVNwZWNpYWx0eSIsImdldEFsbFN1YnNwZWNpYWx0aWVzIiwic3BlY2lhbHR5SWQiLCJ1cHNlcnRTdWJzcGVjaWFsdHkiLCJzdWJzcGVjaWFsdHkiLCJkZWxldGVTdWJzcGVjaWFsdHkiLCJhY2NlcHRBcHBvaW50bWVudCIsImFwcG9pbnRtZW50SWQiLCJkZWNsaW5lQXBwb2ludG1lbnQiLCJFcnJvciIsIk1hcCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/services/httpService.ts\n"));

/***/ })

});